import { type PluginOptions } from '@zenstackhq/sdk';
import { isDataModel, type DataModel, type Model } from '@zenstackhq/sdk/ast';
import * as fs from 'fs-extra';

const OUTPUT_PATH = '../frontend/src/@generated/db.service.ts';

const CONTENT = `
// =====================================================
//  DO NOT MODIFY THIS FILE !!
//  THIS FILE IS AUTOMATICALLY GENERATED ...
//  READ THE INSTRUCTIONS CAREFULLY !!! 
// =====================================================

import { inject, Injectable } from "@angular/core";
import { CoreService } from "@simply-direct/ngx-core";
import { Prisma,<#ENTITIES_LIST#> } from "@prisma/client"

@Injectable()
export class DbService {
    private readonly core = inject(CoreService);
    <#ENTITIES_BLOCKS#>
}`

const BLOCK = `
    <ntt> = {
        create: async (args:Prisma.<Ntt>CreateArgs):Promise<<Ntt> | null> => { return await this.core.prisma('<ntt>.create',args); },
        createMany: async (args:Prisma.<Ntt>CreateManyArgs): Promise<Prisma.BatchPayload | null> => { return await this.core.prisma('<ntt>.createMany',args); },
        findMany: async (args?: Prisma.<Ntt>FindManyArgs):Promise<<Ntt>[] | null> => { return await this.core.prisma('<ntt>.findMany',args); },
        findFirst: async (args?: Prisma.<Ntt>FindFirstArgs):Promise<<Ntt> | null> => { return await this.core.prisma('<ntt>.findFirst',args); },
        findUnique: async (args:Prisma.<Ntt>FindUniqueArgs):Promise<<Ntt> | null> => { return await this.core.prisma('<ntt>.findUnique',args); },
        update: async (args: Prisma.<Ntt>UpdateArgs):Promise<<Ntt> | null> => { return await this.core.prisma('<ntt>.update',args); },
        updateMany: async (args: Prisma.<Ntt>UpdateManyArgs): Promise<Prisma.BatchPayload | null> => { return await this.core.prisma('<ntt>.updateMany',args); },
        upsert: async (args:Prisma.<Ntt>UpsertArgs):Promise<<Ntt> | null> => { return await this.core.prisma('<ntt>.upsert',args); },
        count: async (args?:Prisma.<Ntt>CountArgs): Promise<number | null> => { return await this.core.prisma('<ntt>.count',args); },
        aggregate: async (args:Prisma.<Ntt>AggregateArgs): Promise<Prisma.Get<Ntt>AggregateType<Prisma.<Ntt>AggregateArgs> | null> => { return await this.core.prisma('<ntt>.aggregate',args); },
        groupBy: async <T>(args:Prisma.<Ntt>GroupByArgs): Promise<T[] | null> => { return await this.core.prisma('<ntt>.groupBy',args); },
        delete: async (args:Prisma.<Ntt>DeleteArgs): Promise<<Ntt> | null> => { return await this.core.prisma('<ntt>.delete',args); },
        deleteMany: async (args?:Prisma.<Ntt>DeleteManyArgs): Promise<Prisma.BatchPayload | null> => { return await this.core.prisma('<ntt>.deleteMany',args); },     
    }
`

function firstLetterLowercase(str: string): string {
  if (!str || str.length === 0) return str;
  return str.charAt(0).toLowerCase() + str.slice(1);
}

function firstLetterUppercase(str: string): string {
  if (!str || str.length === 0) return str;
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function replaceAll(str: string, searchValue: string, replaceValue: string): string {
  if (!str || searchValue === '') return str;
  return str.split(searchValue).join(replaceValue);
}

export default async function run(model: Model, options: PluginOptions) {
  
  // get all data models
  const dataModels = model.declarations.filter((x): x is DataModel => isDataModel(x));

  // TOC
  const entities = dataModels.map(x => x.name);

  let blocks = '';

  for(const entity of entities) {
    let eb = BLOCK;
    const ntt = firstLetterLowercase(entity);
    const Ntt = firstLetterUppercase(entity);
    eb = replaceAll(eb,'<ntt>',ntt);
    eb = replaceAll(eb,'<Ntt>',Ntt);
    blocks += eb;
  }

  let content = CONTENT;
  content = content.replace('<#ENTITIES_LIST#>',entities.join(','));
  content = content.replace('<#ENTITIES_BLOCKS#>',blocks);

  let existing = '';
  try {
    if (fs.existsSync(OUTPUT_PATH)) existing = fs.readFileSync(OUTPUT_PATH, 'utf8');
  } catch {}

  if (existing === content) {
    console.log(`⚠️ It is not necessary to create a new DbService`);
  } else {
    fs.writeFileSync(OUTPUT_PATH, content, 'utf8');
    console.log(`✅ New DbService created !`);
  }

}
